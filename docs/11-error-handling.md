# ‚ö†Ô∏è Error Handling

El **manejo de errores** es crucial para crear APIs robustas y amigables. Permite proporcionar respuestas consistentes, debugging efectivo y mejor experiencia del usuario.

## üéØ Tipos de Errores

### 1. **Errores de Validaci√≥n** - Datos inv√°lidos o faltantes
### 2. **Errores de Negocio** - L√≥gica de aplicaci√≥n
### 3. **Errores de Sistema** - Bases de datos, red, etc.
### 4. **Errores de Seguridad** - Autenticaci√≥n, autorizaci√≥n
### 5. **Errores de Cliente** - Requests malformados

---

## üèóÔ∏è 1. Sistema de Errores Estructurado

```dart
// error/api_error.dart
class ApiError implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final Map<String, dynamic>? details;
  final String? field;
  final dynamic originalError;
  
  const ApiError({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
    this.field,
    this.originalError,
  });
  
  // Factory constructors para tipos comunes de errores
  factory ApiError.validation(String message, {String? field, Map<String, dynamic>? details}) {
    return ApiError(
      code: 'VALIDATION_ERROR',
      message: message,
      statusCode: 400,
      field: field,
      details: details,
    );
  }
  
  factory ApiError.notFound(String resource, {String? id}) {
    return ApiError(
      code: 'NOT_FOUND',
      message: id != null ? '$resource with ID "$id" not found' : '$resource not found',
      statusCode: 404,
      details: {'resource': resource, 'id': id},
    );
  }
  
  factory ApiError.unauthorized(String message) {
    return ApiError(
      code: 'UNAUTHORIZED',
      message: message,
      statusCode: 401,
    );
  }
  
  factory ApiError.forbidden(String message) {
    return ApiError(
      code: 'FORBIDDEN',
      message: message,
      statusCode: 403,
    );
  }
  
  factory ApiError.conflict(String message, {Map<String, dynamic>? details}) {
    return ApiError(
      code: 'CONFLICT',
      message: message,
      statusCode: 409,
      details: details,
    );
  }
  
  factory ApiError.tooManyRequests(String message, {int? retryAfter}) {
    return ApiError(
      code: 'TOO_MANY_REQUESTS',\n      message: message,\n      statusCode: 429,\n      details: retryAfter != null ? {'retry_after': retryAfter} : null,\n    );\n  }\n  \n  factory ApiError.internal(String message, {dynamic originalError}) {\n    return ApiError(\n      code: 'INTERNAL_ERROR',\n      message: message,\n      statusCode: 500,\n      originalError: originalError,\n    );\n  }\n  \n  factory ApiError.badRequest(String message, {Map<String, dynamic>? details}) {\n    return ApiError(\n      code: 'BAD_REQUEST',\n      message: message,\n      statusCode: 400,\n      details: details,\n    );\n  }\n  \n  factory ApiError.unprocessableEntity(String message, {List<ValidationError>? validationErrors}) {\n    return ApiError(\n      code: 'UNPROCESSABLE_ENTITY',\n      message: message,\n      statusCode: 422,\n      details: validationErrors != null ? {\n        'validation_errors': validationErrors.map((e) => e.toJson()).toList()\n      } : null,\n    );\n  }\n  \n  Map<String, dynamic> toJson() {\n    final json = {\n      'success': false,\n      'error': {\n        'code': code,\n        'message': message,\n        'status_code': statusCode,\n      },\n    };\n    \n    if (field != null) {\n      json['error']['field'] = field;\n    }\n    \n    if (details != null && details!.isNotEmpty) {\n      json['error']['details'] = details;\n    }\n    \n    // Agregar timestamp\n    json['timestamp'] = DateTime.now().toIso8601String();\n    \n    return json;\n  }\n  \n  @override\n  String toString() {\n    return 'ApiError($code): $message (Status: $statusCode)';\n  }\n}\n\nclass ValidationError {\n  final String field;\n  final String message;\n  final dynamic rejectedValue;\n  final String? code;\n  \n  const ValidationError({\n    required this.field,\n    required this.message,\n    this.rejectedValue,\n    this.code,\n  });\n  \n  Map<String, dynamic> toJson() {\n    return {\n      'field': field,\n      'message': message,\n      if (rejectedValue != null) 'rejected_value': rejectedValue,\n      if (code != null) 'code': code,\n    };\n  }\n}\n```\n\n---\n\n## üõ°Ô∏è 2. Middleware de Manejo de Errores\n\n```dart\n// middleware/error_handling_middleware.dart\nclass ErrorHandlingMiddleware {\n  \n  // Middleware principal de manejo de errores\n  static Middleware errorHandler() {\n    return (Handler innerHandler) {\n      return (Request request) async {\n        try {\n          return await innerHandler(request);\n          \n        } on ApiError catch (apiError) {\n          // Errores controlados de la aplicaci√≥n\n          return _handleApiError(apiError, request);\n          \n        } on FormatException catch (e) {\n          // Errores de formato JSON\n          return _handleFormatError(e, request);\n          \n        } on ArgumentError catch (e) {\n          // Errores de argumentos\n          return _handleArgumentError(e, request);\n          \n        } on StateError catch (e) {\n          // Errores de estado\n          return _handleStateError(e, request);\n          \n        } catch (error, stackTrace) {\n          // Errores no controlados\n          return _handleUnknownError(error, stackTrace, request);\n        }\n      };\n    };\n  }\n  \n  static Response _handleApiError(ApiError apiError, Request request) {\n    final requestId = request.context['request_id'] as String? ?? 'unknown';\n    \n    // Log seg√∫n severidad\n    if (apiError.statusCode >= 500) {\n      print('üí• [$requestId] Server Error: ${apiError.code} - ${apiError.message}');\n      if (apiError.originalError != null) {\n        print('   Original Error: ${apiError.originalError}');\n      }\n    } else if (apiError.statusCode >= 400) {\n      print('‚ö†Ô∏è [$requestId] Client Error: ${apiError.code} - ${apiError.message}');\n    }\n    \n    return Response.json(\n      jsonEncode(apiError.toJson()),\n      statusCode: apiError.statusCode,\n      headers: _getErrorHeaders(requestId),\n    );\n  }\n  \n  static Response _handleFormatError(FormatException e, Request request) {\n    final requestId = request.context['request_id'] as String? ?? 'unknown';\n    print('üìù [$requestId] Format Error: ${e.message}');\n    \n    final apiError = ApiError.badRequest(\n      'Invalid JSON format in request body',\n      details: {'format_error': e.message},\n    );\n    \n    return Response.json(\n      jsonEncode(apiError.toJson()),\n      statusCode: 400,\n      headers: _getErrorHeaders(requestId),\n    );\n  }\n  \n  static Response _handleArgumentError(ArgumentError e, Request request) {\n    final requestId = request.context['request_id'] as String? ?? 'unknown';\n    print('üî¢ [$requestId] Argument Error: ${e.message}');\n    \n    final apiError = ApiError.badRequest(\n      'Invalid argument provided',\n      details: {'argument_error': e.message, 'invalid_value': e.invalidValue},\n    );\n    \n    return Response.json(\n      jsonEncode(apiError.toJson()),\n      statusCode: 400,\n      headers: _getErrorHeaders(requestId),\n    );\n  }\n  \n  static Response _handleStateError(StateError e, Request request) {\n    final requestId = request.context['request_id'] as String? ?? 'unknown';\n    print('üîÑ [$requestId] State Error: ${e.message}');\n    \n    final apiError = ApiError.badRequest(\n      'Invalid operation state',\n      details: {'state_error': e.message},\n    );\n    \n    return Response.json(\n      jsonEncode(apiError.toJson()),\n      statusCode: 400,\n      headers: _getErrorHeaders(requestId),\n    );\n  }\n  \n  static Response _handleUnknownError(dynamic error, StackTrace stackTrace, Request request) {\n    final requestId = request.context['request_id'] as String? ?? 'unknown';\n    \n    print('üíÄ [$requestId] UNKNOWN ERROR: $error');\n    print('   Stack trace: ${stackTrace.toString().split('\\n').take(10).join('\\n')}');\n    \n    // En producci√≥n, no exponer detalles del error interno\n    final isDevelopment = const bool.fromEnvironment('dart.vm.product') == false;\n    \n    final apiError = ApiError.internal(\n      'An unexpected error occurred',\n      originalError: isDevelopment ? error.toString() : null,\n    );\n    \n    return Response.json(\n      jsonEncode({\n        ...apiError.toJson(),\n        if (isDevelopment) 'debug_info': {\n          'error_type': error.runtimeType.toString(),\n          'stack_trace': stackTrace.toString().split('\\n').take(20).toList(),\n        },\n      }),\n      statusCode: 500,\n      headers: _getErrorHeaders(requestId),\n    );\n  }\n  \n  static Map<String, String> _getErrorHeaders(String requestId) {\n    return {\n      'Content-Type': 'application/json',\n      'X-Request-ID': requestId,\n      'X-Error-Handled': 'true',\n    };\n  }\n}\n```\n\n---\n\n## üìã 3. Validador de Datos con Errores Detallados\n\n```dart\n// validators/data_validator.dart\nclass DataValidator {\n  \n  // Validar datos de usuario\n  static void validateUserData(Map<String, dynamic> data, {bool isUpdate = false}) {\n    final errors = <ValidationError>[];\n    \n    // Validar email\n    if (!isUpdate || data.containsKey('email')) {\n      final email = data['email'];\n      if (email == null || email.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'email',\n            message: 'Email is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final emailStr = email.toString().trim();\n        if (!_isValidEmail(emailStr)) {\n          errors.add(ValidationError(\n            field: 'email',\n            message: 'Invalid email format',\n            rejectedValue: emailStr,\n            code: 'INVALID_FORMAT',\n          ));\n        }\n      }\n    }\n    \n    // Validar nombre\n    if (!isUpdate || data.containsKey('name')) {\n      final name = data['name'];\n      if (name == null || name.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'name',\n            message: 'Name is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final nameStr = name.toString().trim();\n        if (nameStr.length < 2) {\n          errors.add(ValidationError(\n            field: 'name',\n            message: 'Name must be at least 2 characters long',\n            rejectedValue: nameStr,\n            code: 'MIN_LENGTH',\n          ));\n        } else if (nameStr.length > 100) {\n          errors.add(ValidationError(\n            field: 'name',\n            message: 'Name must not exceed 100 characters',\n            rejectedValue: nameStr,\n            code: 'MAX_LENGTH',\n          ));\n        }\n      }\n    }\n    \n    // Validar edad\n    if (data.containsKey('age')) {\n      final age = data['age'];\n      if (age != null) {\n        if (age is! int) {\n          errors.add(ValidationError(\n            field: 'age',\n            message: 'Age must be an integer',\n            rejectedValue: age,\n            code: 'INVALID_TYPE',\n          ));\n        } else if (age < 0) {\n          errors.add(ValidationError(\n            field: 'age',\n            message: 'Age cannot be negative',\n            rejectedValue: age,\n            code: 'MIN_VALUE',\n          ));\n        } else if (age > 150) {\n          errors.add(ValidationError(\n            field: 'age',\n            message: 'Age cannot exceed 150',\n            rejectedValue: age,\n            code: 'MAX_VALUE',\n          ));\n        }\n      }\n    }\n    \n    // Validar role\n    if (data.containsKey('role')) {\n      final role = data['role'];\n      if (role != null) {\n        final validRoles = ['user', 'admin', 'moderator'];\n        if (!validRoles.contains(role)) {\n          errors.add(ValidationError(\n            field: 'role',\n            message: 'Role must be one of: ${validRoles.join(', ')}',\n            rejectedValue: role,\n            code: 'INVALID_ENUM',\n          ));\n        }\n      }\n    }\n    \n    if (errors.isNotEmpty) {\n      throw ApiError.unprocessableEntity(\n        'Validation failed',\n        validationErrors: errors,\n      );\n    }\n  }\n  \n  // Validar datos de producto\n  static void validateProductData(Map<String, dynamic> data, {bool isUpdate = false}) {\n    final errors = <ValidationError>[];\n    \n    // Validar nombre\n    if (!isUpdate || data.containsKey('name')) {\n      final name = data['name'];\n      if (name == null || name.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'name',\n            message: 'Product name is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final nameStr = name.toString().trim();\n        if (nameStr.length < 3) {\n          errors.add(ValidationError(\n            field: 'name',\n            message: 'Product name must be at least 3 characters long',\n            rejectedValue: nameStr,\n            code: 'MIN_LENGTH',\n          ));\n        }\n      }\n    }\n    \n    // Validar precio\n    if (!isUpdate || data.containsKey('price')) {\n      final price = data['price'];\n      if (price == null) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'price',\n            message: 'Price is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else if (price is! num) {\n        errors.add(ValidationError(\n          field: 'price',\n          message: 'Price must be a number',\n          rejectedValue: price,\n          code: 'INVALID_TYPE',\n        ));\n      } else if (price <= 0) {\n        errors.add(ValidationError(\n          field: 'price',\n          message: 'Price must be greater than 0',\n          rejectedValue: price,\n          code: 'MIN_VALUE',\n        ));\n      } else if (price > 1000000) {\n        errors.add(ValidationError(\n          field: 'price',\n          message: 'Price cannot exceed 1,000,000',\n          rejectedValue: price,\n          code: 'MAX_VALUE',\n        ));\n      }\n    }\n    \n    // Validar stock\n    if (data.containsKey('stock')) {\n      final stock = data['stock'];\n      if (stock != null && stock is! int) {\n        errors.add(ValidationError(\n          field: 'stock',\n          message: 'Stock must be an integer',\n          rejectedValue: stock,\n          code: 'INVALID_TYPE',\n        ));\n      } else if (stock != null && stock < 0) {\n        errors.add(ValidationError(\n          field: 'stock',\n          message: 'Stock cannot be negative',\n          rejectedValue: stock,\n          code: 'MIN_VALUE',\n        ));\n      }\n    }\n    \n    // Validar categor√≠a\n    if (!isUpdate || data.containsKey('category')) {\n      final category = data['category'];\n      if (category == null || category.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'category',\n            message: 'Category is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final validCategories = ['electronics', 'clothing', 'books', 'home', 'sports'];\n        if (!validCategories.contains(category)) {\n          errors.add(ValidationError(\n            field: 'category',\n            message: 'Category must be one of: ${validCategories.join(', ')}',\n            rejectedValue: category,\n            code: 'INVALID_ENUM',\n          ));\n        }\n      }\n    }\n    \n    if (errors.isNotEmpty) {\n      throw ApiError.unprocessableEntity(\n        'Product validation failed',\n        validationErrors: errors,\n      );\n    }\n  }\n  \n  static bool _isValidEmail(String email) {\n    return RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$').hasMatch(email);\n  }\n}\n```\n\n---\n\n## üéØ 4. Uso en Controladores\n\n```dart\n@Controller('/api/users')\nclass UserController extends BaseController {\n  \n  static final List<Map<String, dynamic>> _users = [];\n  \n  // POST /api/users/\n  @POST('/')\n  Future<Response> createUser(Request request) async {\n    logRequest(request, 'Creating new user');\n    \n    // El middleware de error handling capturar√° las excepciones\n    final body = await request.readAsString();\n    if (body.isEmpty) {\n      throw ApiError.badRequest('Request body is required');\n    }\n    \n    final data = jsonDecode(body) as Map<String, dynamic>;\n    \n    // Validar datos (puede lanzar ApiError.unprocessableEntity)\n    DataValidator.validateUserData(data);\n    \n    // Verificar email √∫nico\n    final email = data['email'].toString().trim().toLowerCase();\n    if (_users.any((user) => user['email'] == email)) {\n      throw ApiError.conflict(\n        'Email already exists',\n        details: {'email': email, 'suggestion': 'Use a different email address'},\n      );\n    }\n    \n    // Crear usuario\n    final newUser = {\n      'id': DateTime.now().millisecondsSinceEpoch.toString(),\n      'name': data['name'].toString().trim(),\n      'email': email,\n      'age': data['age'],\n      'role': data['role'] ?? 'user',\n      'created_at': DateTime.now().toIso8601String(),\n    };\n    \n    _users.add(newUser);\n    \n    print('‚úÖ User created: ${newUser['name']} (${newUser['email']})');\n    \n    final response = ApiResponse.success(newUser, 'User created successfully');\n    return jsonResponse(response.toJson(), statusCode: 201);\n  }\n  \n  // GET /api/users/{id}\n  @GET('/<id>')\n  Future<Response> getUser(Request request) async {\n    final userId = getRequiredParam(request, 'id');\n    logRequest(request, 'Getting user $userId');\n    \n    final user = _users.firstWhere(\n      (u) => u['id'] == userId,\n      orElse: () => {},\n    );\n    \n    if (user.isEmpty) {\n      throw ApiError.notFound('User', id: userId);\n    }\n    \n    final response = ApiResponse.success(user, 'User retrieved successfully');\n    return jsonResponse(response.toJson());\n  }\n  \n  // PUT /api/users/{id}\n  @PUT('/<id>')\n  Future<Response> updateUser(Request request) async {\n    final userId = getRequiredParam(request, 'id');\n    logRequest(request, 'Updating user $userId');\n    \n    final userIndex = _users.indexWhere((u) => u['id'] == userId);\n    if (userIndex == -1) {\n      throw ApiError.notFound('User', id: userId);\n    }\n    \n    final body = await request.readAsString();\n    if (body.isEmpty) {\n      throw ApiError.badRequest('Request body is required');\n    }\n    \n    final data = jsonDecode(body) as Map<String, dynamic>;\n    \n    // Validar datos de actualizaci√≥n\n    DataValidator.validateUserData(data, isUpdate: true);\n    \n    // Verificar email √∫nico (excluyendo el usuario actual)\n    if (data.containsKey('email')) {\n      final email = data['email'].toString().trim().toLowerCase();\n      if (_users.any((user) => user['id'] != userId && user['email'] == email)) {\n        throw ApiError.conflict(\n          'Email already exists',\n          details: {'email': email},\n        );\n      }\n    }\n    \n    // Actualizar usuario\n    final user = _users[userIndex];\n    if (data.containsKey('name')) user['name'] = data['name'].toString().trim();\n    if (data.containsKey('email')) user['email'] = data['email'].toString().trim().toLowerCase();\n    if (data.containsKey('age')) user['age'] = data['age'];\n    if (data.containsKey('role')) user['role'] = data['role'];\n    user['updated_at'] = DateTime.now().toIso8601String();\n    \n    print('‚úÖ User updated: ${user['name']} (${user['email']})');\n    \n    final response = ApiResponse.success(user, 'User updated successfully');\n    return jsonResponse(response.toJson());\n  }\n  \n  // DELETE /api/users/{id}\n  @DELETE('/<id>')\n  Future<Response> deleteUser(Request request) async {\n    final userId = getRequiredParam(request, 'id');\n    logRequest(request, 'Deleting user $userId');\n    \n    final userIndex = _users.indexWhere((u) => u['id'] == userId);\n    if (userIndex == -1) {\n      throw ApiError.notFound('User', id: userId);\n    }\n    \n    // Verificar que no sea el √∫ltimo admin\n    final user = _users[userIndex];\n    if (user['role'] == 'admin') {\n      final adminCount = _users.where((u) => u['role'] == 'admin').length;\n      if (adminCount <= 1) {\n        throw ApiError.conflict(\n          'Cannot delete the last admin user',\n          details: {\n            'reason': 'At least one admin user must exist',\n            'suggestion': 'Create another admin user before deleting this one',\n          },\n        );\n      }\n    }\n    \n    _users.removeAt(userIndex);\n    \n    print('üóëÔ∏è User deleted: ${user['name']} (${user['email']})');\n    \n    final response = ApiResponse.success({\n      'deleted_user': {\n        'id': user['id'],\n        'name': user['name'],\n        'email': user['email'],\n      },\n      'deleted_at': DateTime.now().toIso8601String(),\n    }, 'User deleted successfully');\n    \n    return jsonResponse(response.toJson());\n  }\n}\n```\n\n**Respuestas de error estructuradas:**\n```json\n// Error de validaci√≥n (422)\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"UNPROCESSABLE_ENTITY\",\n    \"message\": \"Validation failed\",\n    \"status_code\": 422,\n    \"details\": {\n      \"validation_errors\": [\n        {\n          \"field\": \"email\",\n          \"message\": \"Invalid email format\",\n          \"rejected_value\": \"invalid-email\",\n          \"code\": \"INVALID_FORMAT\"\n        },\n        {\n          \"field\": \"age\",\n          \"message\": \"Age must be an integer\",\n          \"rejected_value\": \"not-a-number\",\n          \"code\": \"INVALID_TYPE\"\n        }\n      ]\n    }\n  },\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\"\n}\n\n// Error de conflicto (409)\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"CONFLICT\",\n    \"message\": \"Email already exists\",\n    \"status_code\": 409,\n    \"details\": {\n      \"email\": \"user@example.com\",\n      \"suggestion\": \"Use a different email address\"\n    }\n  },\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\"\n}\n\n// Error no encontrado (404)\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"NOT_FOUND\",\n    \"message\": \"User with ID \\\"123\\\" not found\",\n    \"status_code\": 404,\n    \"details\": {\n      \"resource\": \"User\",\n      \"id\": \"123\"\n    }\n  },\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\"\n}\n```\n\n---\n\n## üèÜ Mejores Pr√°cticas para Error Handling\n\n### ‚úÖ **DO's**\n- ‚úÖ Usar c√≥digos de error consistentes\n- ‚úÖ Proporcionar mensajes descriptivos\n- ‚úÖ Incluir detalles √∫tiles para debugging\n- ‚úÖ Loggear errores con context adecuado\n- ‚úÖ Manejar errores en middleware centralizado\n- ‚úÖ Validar input y lanzar errores espec√≠ficos\n\n### ‚ùå **DON'Ts**\n- ‚ùå Exponer stack traces en producci√≥n\n- ‚ùå Usar solo c√≥digos de status HTTP\n- ‚ùå Ignorar o suprimir errores silenciosamente\n- ‚ùå Retornar informaci√≥n sensible en errores\n- ‚ùå Usar excepciones para control de flujo normal\n\n### üìä C√≥digos de Error Recomendados\n```\nVALIDATION_ERROR (400)     - Datos inv√°lidos\nUNAUTHORIZED (401)         - Falta autenticaci√≥n\nFORBIDDEN (403)            - Sin permisos\nNOT_FOUND (404)            - Recurso no encontrado\nCONFLICT (409)             - Conflicto de datos\nUNPROCESSABLE_ENTITY (422) - Errores de validaci√≥n detallados\nTOO_MANY_REQUESTS (429)    - Rate limiting\nINTERNAL_ERROR (500)       - Errores de servidor\n```\n\n### üîç Logging de Errores\n```dart\n// Error logging con contexto\nprint('‚ùå [${requestId}] ${error.code}: ${error.message}');\nprint('   User: ${userId ?? 'anonymous'}');\nprint('   IP: ${clientIp}');\nprint('   User-Agent: ${userAgent}');\nprint('   Request: ${method} ${path}');\nif (error.originalError != null) {\n  print('   Original: ${error.originalError}');\n}\n```\n\n---\n\n**üëâ [Siguiente: Testing ‚Üí](12-testing.md)**