# üí° Examples y Uso Avanzado

Esta secci√≥n presenta **ejemplos completos** y casos de uso avanzados del framework api_kit. Desde APIs simples hasta sistemas empresariales complejos.

## üéØ Ejemplos Incluidos

### 1. **Blog API** - CRUD completo con autenticaci√≥n
### 2. **E-commerce API** - Sistema de productos y √≥rdenes
### 3. **Task Management API** - Gesti√≥n de tareas con equipos
### 4. **Real-time Chat API** - WebSockets y eventos
### 5. **File Upload API** - Manejo de archivos multimedia

---

## üìù 1. Blog API Completo

```dart
// blog_api/models/post.dart
class Post {
  final String id;
  final String title;
  final String content;
  final String authorId;
  final List<String> tags;
  final PostStatus status;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? publishedAt;
  final int viewCount;
  final List<String> categoryIds;
  
  Post({
    required this.id,
    required this.title,
    required this.content,
    required this.authorId,
    this.tags = const [],
    this.status = PostStatus.draft,
    required this.createdAt,
    required this.updatedAt,
    this.publishedAt,
    this.viewCount = 0,
    this.categoryIds = const [],
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'content': content,
    'author_id': authorId,
    'tags': tags,
    'status': status.name,
    'created_at': createdAt.toIso8601String(),
    'updated_at': updatedAt.toIso8601String(),
    'published_at': publishedAt?.toIso8601String(),
    'view_count': viewCount,
    'category_ids': categoryIds,
  };
}

enum PostStatus { draft, published, archived }

class Category {
  final String id;
  final String name;
  final String description;
  final String? parentId;
  final DateTime createdAt;
  
  Category({
    required this.id,
    required this.name,
    required this.description,
    this.parentId,
    required this.createdAt,
  });
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'description': description,
    'parent_id': parentId,
    'created_at': createdAt.toIso8601String(),
  };
}
```

```dart
// blog_api/controllers/posts_controller.dart
@Controller('/api/posts')
class PostsController extends BaseController {
  
  static final List<Post> _posts = [];
  static final List<Category> _categories = [
    Category(
      id: '1',
      name: 'Technology',
      description: 'Tech articles and tutorials',
      createdAt: DateTime.now(),
    ),
    Category(
      id: '2',
      name: 'Programming',
      description: 'Programming languages and frameworks',
      parentId: '1',
      createdAt: DateTime.now(),
    ),
  ];
  
  // GET /api/posts?status=published&category=1&tag=dart&search=flutter&sort=created_at&order=desc&page=1&limit=10
  @GET('/')
  Future<Response> getPosts(Request request) async {
    logRequest(request, 'Getting posts with filters');
    
    try {
      // Extraer par√°metros de filtrado
      final status = getOptionalQueryParam(request, 'status');
      final categoryId = getOptionalQueryParam(request, 'category');
      final tag = getOptionalQueryParam(request, 'tag');
      final search = getOptionalQueryParam(request, 'search');
      final authorId = getOptionalQueryParam(request, 'author');
      
      // Par√°metros de paginaci√≥n y ordenamiento
      final page = int.tryParse(getOptionalQueryParam(request, 'page', '1')) ?? 1;
      final limit = int.tryParse(getOptionalQueryParam(request, 'limit', '10')) ?? 10;
      final sortBy = getOptionalQueryParam(request, 'sort', 'created_at');\n      final order = getOptionalQueryParam(request, 'order', 'desc');\n      \n      // Aplicar filtros\n      var filteredPosts = _posts.where((post) {\n        // Filtro por status\n        if (status != null && post.status.name != status) return false;\n        \n        // Filtro por categor√≠a\n        if (categoryId != null && !post.categoryIds.contains(categoryId)) return false;\n        \n        // Filtro por tag\n        if (tag != null && !post.tags.contains(tag)) return false;\n        \n        // Filtro por autor\n        if (authorId != null && post.authorId != authorId) return false;\n        \n        // B√∫squeda de texto\n        if (search != null) {\n          final searchLower = search.toLowerCase();\n          if (!post.title.toLowerCase().contains(searchLower) &&\n              !post.content.toLowerCase().contains(searchLower) &&\n              !post.tags.any((t) => t.toLowerCase().contains(searchLower))) {\n            return false;\n          }\n        }\n        \n        return true;\n      }).toList();\n      \n      // Ordenar\n      filteredPosts.sort((a, b) {\n        dynamic aValue, bValue;\n        switch (sortBy) {\n          case 'title':\n            aValue = a.title;\n            bValue = b.title;\n            break;\n          case 'created_at':\n            aValue = a.createdAt;\n            bValue = b.createdAt;\n            break;\n          case 'updated_at':\n            aValue = a.updatedAt;\n            bValue = b.updatedAt;\n            break;\n          case 'view_count':\n            aValue = a.viewCount;\n            bValue = b.viewCount;\n            break;\n          default:\n            aValue = a.createdAt;\n            bValue = b.createdAt;\n        }\n        \n        final result = aValue.compareTo(bValue);\n        return order == 'desc' ? -result : result;\n      });\n      \n      // Paginaci√≥n\n      final totalPosts = filteredPosts.length;\n      final offset = (page - 1) * limit;\n      final paginatedPosts = filteredPosts.skip(offset).take(limit).toList();\n      \n      // Enriquecer con datos de autor y categor√≠as\n      final enrichedPosts = await _enrichPostsWithDetails(paginatedPosts);\n      \n      final response = ApiResponse.success({\n        'posts': enrichedPosts,\n        'pagination': {\n          'current_page': page,\n          'per_page': limit,\n          'total_posts': totalPosts,\n          'total_pages': (totalPosts / limit).ceil(),\n          'has_next': offset + limit < totalPosts,\n          'has_previous': page > 1,\n        },\n        'filters': {\n          'status': status,\n          'category': categoryId,\n          'tag': tag,\n          'search': search,\n          'author': authorId,\n        },\n        'sorting': {\n          'sort_by': sortBy,\n          'order': order,\n        },\n      }, 'Posts retrieved successfully');\n      \n      return jsonResponse(response.toJson());\n      \n    } catch (e) {\n      throw ApiError.internal('Error retrieving posts', originalError: e);\n    }\n  }\n  \n  // GET /api/posts/{id}\n  @GET('/<id>')\n  Future<Response> getPost(Request request) async {\n    final postId = getRequiredParam(request, 'id');\n    logRequest(request, 'Getting post $postId');\n    \n    final post = _posts.firstWhere(\n      (p) => p.id == postId,\n      orElse: () => throw ApiError.notFound('Post', id: postId),\n    );\n    \n    // Incrementar contador de vistas\n    final postIndex = _posts.indexWhere((p) => p.id == postId);\n    _posts[postIndex] = Post(\n      id: post.id,\n      title: post.title,\n      content: post.content,\n      authorId: post.authorId,\n      tags: post.tags,\n      status: post.status,\n      createdAt: post.createdAt,\n      updatedAt: post.updatedAt,\n      publishedAt: post.publishedAt,\n      viewCount: post.viewCount + 1,\n      categoryIds: post.categoryIds,\n    );\n    \n    // Enriquecer con detalles\n    final enrichedPost = await _enrichPostWithDetails(_posts[postIndex]);\n    \n    final response = ApiResponse.success(enrichedPost, 'Post retrieved successfully');\n    return jsonResponse(response.toJson());\n  }\n  \n  // POST /api/posts\n  @POST('/')\n  Future<Response> createPost(Request request) async {\n    logRequest(request, 'Creating new post');\n    \n    final userId = request.context['user_id'] as String?;\n    if (userId == null) {\n      throw ApiError.unauthorized('Authentication required');\n    }\n    \n    final body = await request.readAsString();\n    if (body.isEmpty) {\n      throw ApiError.badRequest('Request body is required');\n    }\n    \n    final data = jsonDecode(body) as Map<String, dynamic>;\n    \n    // Validar datos\n    _validatePostData(data);\n    \n    // Verificar categor√≠as\n    final categoryIds = List<String>.from(data['category_ids'] ?? []);\n    for (final categoryId in categoryIds) {\n      if (!_categories.any((c) => c.id == categoryId)) {\n        throw ApiError.badRequest('Category with ID \"$categoryId\" not found');\n      }\n    }\n    \n    // Crear post\n    final now = DateTime.now();\n    final post = Post(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      title: data['title'].toString().trim(),\n      content: data['content'].toString().trim(),\n      authorId: userId,\n      tags: List<String>.from(data['tags'] ?? []),\n      status: PostStatus.values.firstWhere(\n        (s) => s.name == (data['status'] ?? 'draft'),\n        orElse: () => PostStatus.draft,\n      ),\n      createdAt: now,\n      updatedAt: now,\n      publishedAt: data['status'] == 'published' ? now : null,\n      categoryIds: categoryIds,\n    );\n    \n    _posts.add(post);\n    \n    print('‚úÖ Post created: \"${post.title}\" by user $userId');\n    \n    // Enriquecer respuesta\n    final enrichedPost = await _enrichPostWithDetails(post);\n    \n    final response = ApiResponse.success(enrichedPost, 'Post created successfully');\n    return jsonResponse(response.toJson(), statusCode: 201);\n  }\n  \n  // PUT /api/posts/{id}\n  @PUT('/<id>')\n  Future<Response> updatePost(Request request) async {\n    final postId = getRequiredParam(request, 'id');\n    logRequest(request, 'Updating post $postId');\n    \n    final userId = request.context['user_id'] as String?;\n    final userRole = request.context['user_role'] as String?;\n    \n    if (userId == null) {\n      throw ApiError.unauthorized('Authentication required');\n    }\n    \n    final postIndex = _posts.indexWhere((p) => p.id == postId);\n    if (postIndex == -1) {\n      throw ApiError.notFound('Post', id: postId);\n    }\n    \n    final existingPost = _posts[postIndex];\n    \n    // Verificar permisos: solo el autor o admin pueden editar\n    if (existingPost.authorId != userId && userRole != 'admin') {\n      throw ApiError.forbidden('You can only edit your own posts');\n    }\n    \n    final body = await request.readAsString();\n    if (body.isEmpty) {\n      throw ApiError.badRequest('Request body is required');\n    }\n    \n    final data = jsonDecode(body) as Map<String, dynamic>;\n    \n    // Validar datos\n    _validatePostData(data, isUpdate: true);\n    \n    // Verificar categor√≠as si se proporcionan\n    final categoryIds = data.containsKey('category_ids') \n        ? List<String>.from(data['category_ids']) \n        : existingPost.categoryIds;\n    \n    for (final categoryId in categoryIds) {\n      if (!_categories.any((c) => c.id == categoryId)) {\n        throw ApiError.badRequest('Category with ID \"$categoryId\" not found');\n      }\n    }\n    \n    // Determinar si debe actualizarse publishedAt\n    final newStatus = data.containsKey('status') \n        ? PostStatus.values.firstWhere((s) => s.name == data['status']) \n        : existingPost.status;\n    \n    DateTime? publishedAt = existingPost.publishedAt;\n    if (newStatus == PostStatus.published && existingPost.status != PostStatus.published) {\n      publishedAt = DateTime.now();\n    } else if (newStatus != PostStatus.published) {\n      publishedAt = null;\n    }\n    \n    // Actualizar post\n    final updatedPost = Post(\n      id: existingPost.id,\n      title: data.containsKey('title') ? data['title'].toString().trim() : existingPost.title,\n      content: data.containsKey('content') ? data['content'].toString().trim() : existingPost.content,\n      authorId: existingPost.authorId,\n      tags: data.containsKey('tags') ? List<String>.from(data['tags']) : existingPost.tags,\n      status: newStatus,\n      createdAt: existingPost.createdAt,\n      updatedAt: DateTime.now(),\n      publishedAt: publishedAt,\n      viewCount: existingPost.viewCount,\n      categoryIds: categoryIds,\n    );\n    \n    _posts[postIndex] = updatedPost;\n    \n    print('‚úÖ Post updated: \"${updatedPost.title}\" by user $userId');\n    \n    // Enriquecer respuesta\n    final enrichedPost = await _enrichPostWithDetails(updatedPost);\n    \n    final response = ApiResponse.success(enrichedPost, 'Post updated successfully');\n    return jsonResponse(response.toJson());\n  }\n  \n  // DELETE /api/posts/{id}\n  @DELETE('/<id>')\n  Future<Response> deletePost(Request request) async {\n    final postId = getRequiredParam(request, 'id');\n    logRequest(request, 'Deleting post $postId');\n    \n    final userId = request.context['user_id'] as String?;\n    final userRole = request.context['user_role'] as String?;\n    \n    if (userId == null) {\n      throw ApiError.unauthorized('Authentication required');\n    }\n    \n    final postIndex = _posts.indexWhere((p) => p.id == postId);\n    if (postIndex == -1) {\n      throw ApiError.notFound('Post', id: postId);\n    }\n    \n    final post = _posts[postIndex];\n    \n    // Verificar permisos\n    if (post.authorId != userId && userRole != 'admin') {\n      throw ApiError.forbidden('You can only delete your own posts');\n    }\n    \n    _posts.removeAt(postIndex);\n    \n    print('üóëÔ∏è Post deleted: \"${post.title}\" by user $userId');\n    \n    final response = ApiResponse.success({\n      'deleted_post': {\n        'id': post.id,\n        'title': post.title,\n      },\n      'deleted_at': DateTime.now().toIso8601String(),\n    }, 'Post deleted successfully');\n    \n    return jsonResponse(response.toJson());\n  }\n  \n  // GET /api/posts/categories\n  @GET('/categories')\n  Future<Response> getCategories(Request request) async {\n    logRequest(request, 'Getting post categories');\n    \n    // Construir √°rbol de categor√≠as\n    final categoryTree = _buildCategoryTree();\n    \n    final response = ApiResponse.success({\n      'categories': categoryTree,\n      'total_categories': _categories.length,\n    }, 'Categories retrieved successfully');\n    \n    return jsonResponse(response.toJson());\n  }\n  \n  // POST /api/posts/{id}/like\n  @POST('/<id>/like')\n  Future<Response> likePost(Request request) async {\n    final postId = getRequiredParam(request, 'id');\n    final userId = request.context['user_id'] as String?;\n    \n    if (userId == null) {\n      throw ApiError.unauthorized('Authentication required');\n    }\n    \n    // En una implementaci√≥n real, guardar√≠as los likes en BD\n    print('üëç User $userId liked post $postId');\n    \n    final response = ApiResponse.success({\n      'post_id': postId,\n      'user_id': userId,\n      'liked_at': DateTime.now().toIso8601String(),\n    }, 'Post liked successfully');\n    \n    return jsonResponse(response.toJson());\n  }\n  \n  // Validaci√≥n de datos de post\n  void _validatePostData(Map<String, dynamic> data, {bool isUpdate = false}) {\n    final errors = <ValidationError>[];\n    \n    // T√≠tulo\n    if (!isUpdate || data.containsKey('title')) {\n      final title = data['title'];\n      if (title == null || title.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'title',\n            message: 'Title is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final titleStr = title.toString().trim();\n        if (titleStr.length < 5) {\n          errors.add(ValidationError(\n            field: 'title',\n            message: 'Title must be at least 5 characters long',\n            rejectedValue: titleStr,\n            code: 'MIN_LENGTH',\n          ));\n        } else if (titleStr.length > 200) {\n          errors.add(ValidationError(\n            field: 'title',\n            message: 'Title must not exceed 200 characters',\n            rejectedValue: titleStr,\n            code: 'MAX_LENGTH',\n          ));\n        }\n      }\n    }\n    \n    // Contenido\n    if (!isUpdate || data.containsKey('content')) {\n      final content = data['content'];\n      if (content == null || content.toString().trim().isEmpty) {\n        if (!isUpdate) {\n          errors.add(ValidationError(\n            field: 'content',\n            message: 'Content is required',\n            code: 'REQUIRED',\n          ));\n        }\n      } else {\n        final contentStr = content.toString().trim();\n        if (contentStr.length < 50) {\n          errors.add(ValidationError(\n            field: 'content',\n            message: 'Content must be at least 50 characters long',\n            rejectedValue: contentStr.length,\n            code: 'MIN_LENGTH',\n          ));\n        }\n      }\n    }\n    \n    // Tags\n    if (data.containsKey('tags') && data['tags'] is! List) {\n      errors.add(ValidationError(\n        field: 'tags',\n        message: 'Tags must be an array',\n        rejectedValue: data['tags'],\n        code: 'INVALID_TYPE',\n      ));\n    }\n    \n    // Status\n    if (data.containsKey('status')) {\n      final status = data['status'];\n      final validStatuses = PostStatus.values.map((s) => s.name).toList();\n      if (!validStatuses.contains(status)) {\n        errors.add(ValidationError(\n          field: 'status',\n          message: 'Status must be one of: ${validStatuses.join(', ')}',\n          rejectedValue: status,\n          code: 'INVALID_ENUM',\n        ));\n      }\n    }\n    \n    if (errors.isNotEmpty) {\n      throw ApiError.unprocessableEntity(\n        'Post validation failed',\n        validationErrors: errors,\n      );\n    }\n  }\n  \n  // Enriquecer posts con detalles de autor y categor√≠as\n  Future<List<Map<String, dynamic>>> _enrichPostsWithDetails(List<Post> posts) async {\n    return posts.map((post) => _enrichPostWithDetails(post)).toList();\n  }\n  \n  Map<String, dynamic> _enrichPostWithDetails(Post post) {\n    final postJson = post.toJson();\n    \n    // Agregar informaci√≥n del autor (simulada)\n    postJson['author'] = {\n      'id': post.authorId,\n      'name': 'Author ${post.authorId}',\n      'email': 'author${post.authorId}@example.com',\n    };\n    \n    // Agregar informaci√≥n de categor√≠as\n    postJson['categories'] = post.categoryIds.map((categoryId) {\n      final category = _categories.firstWhere(\n        (c) => c.id == categoryId,\n        orElse: () => Category(\n          id: categoryId,\n          name: 'Unknown Category',\n          description: '',\n          createdAt: DateTime.now(),\n        ),\n      );\n      return category.toJson();\n    }).toList();\n    \n    // Estad√≠sticas adicionales\n    postJson['stats'] = {\n      'views': post.viewCount,\n      'likes': 0, // En implementaci√≥n real vendr√≠a de BD\n      'comments': 0, // En implementaci√≥n real vendr√≠a de BD\n    };\n    \n    return postJson;\n  }\n  \n  // Construir √°rbol de categor√≠as\n  List<Map<String, dynamic>> _buildCategoryTree() {\n    final rootCategories = _categories.where((c) => c.parentId == null).toList();\n    \n    return rootCategories.map((category) {\n      final categoryJson = category.toJson();\n      categoryJson['children'] = _getChildCategories(category.id);\n      categoryJson['post_count'] = _posts.where((p) => p.categoryIds.contains(category.id)).length;\n      return categoryJson;\n    }).toList();\n  }\n  \n  List<Map<String, dynamic>> _getChildCategories(String parentId) {\n    final children = _categories.where((c) => c.parentId == parentId).toList();\n    \n    return children.map((category) {\n      final categoryJson = category.toJson();\n      categoryJson['children'] = _getChildCategories(category.id);\n      categoryJson['post_count'] = _posts.where((p) => p.categoryIds.contains(category.id)).length;\n      return categoryJson;\n    }).toList();\n  }\n}\n```\n\n**Tests para el Blog API:**\n```bash\n# Obtener posts con filtros\ncurl \"http://localhost:8080/api/posts?status=published&category=1&page=1&limit=5\"\n\n# Crear nuevo post\ncurl -X POST http://localhost:8080/api/posts \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer your-token\" \\\n  -d '{\n    \"title\": \"Getting Started with Dart\",\n    \"content\": \"This is a comprehensive guide to getting started with Dart programming language. Dart is a client-optimized language for fast apps on any platform...\",\n    \"tags\": [\"dart\", \"programming\", \"tutorial\"],\n    \"status\": \"published\",\n    \"category_ids\": [\"2\"]\n  }'\n\n# Actualizar post\ncurl -X PUT http://localhost:8080/api/posts/1 \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer your-token\" \\\n  -d '{\n    \"title\": \"Advanced Dart Programming\",\n    \"tags\": [\"dart\", \"advanced\", \"programming\"]\n  }'\n\n# Obtener categor√≠as\ncurl http://localhost:8080/api/posts/categories\n\n# Like a post\ncurl -X POST http://localhost:8080/api/posts/1/like \\\n  -H \"Authorization: Bearer your-token\"\n```\n\n---\n\n## üõí 2. E-commerce API\n\n```dart\n// ecommerce_api/controllers/products_controller.dart\n@Controller('/api/products')\nclass ProductsController extends BaseController {\n  \n  static final List<Map<String, dynamic>> _products = [\n    {\n      'id': '1',\n      'name': 'Gaming Laptop',\n      'description': 'High-performance gaming laptop with RTX graphics',\n      'price': 1299.99,\n      'compare_price': 1599.99,\n      'sku': 'LAPTOP-001',\n      'stock': 15,\n      'category_id': 'electronics',\n      'brand': 'TechCorp',\n      'images': [\n        'https://example.com/images/laptop-1.jpg',\n        'https://example.com/images/laptop-2.jpg',\n      ],\n      'specifications': {\n        'processor': 'Intel i7-11800H',\n        'memory': '16GB DDR4',\n        'storage': '512GB SSD',\n        'graphics': 'RTX 3060',\n        'display': '15.6\" FHD 144Hz',\n      },\n      'features': ['Gaming', 'Portable', 'High Performance'],\n      'weight': 2.3,\n      'dimensions': {'length': 35.9, 'width': 25.9, 'height': 2.24},\n      'warranty': '2 years',\n      'rating': 4.5,\n      'review_count': 127,\n      'created_at': '2024-01-01T00:00:00Z',\n      'updated_at': '2024-01-15T10:30:00Z',\n      'is_active': true,\n      'is_featured': true,\n      'seo': {\n        'meta_title': 'Gaming Laptop - High Performance',\n        'meta_description': 'Professional gaming laptop with latest RTX graphics',\n        'slug': 'gaming-laptop-high-performance',\n      },\n    },\n  ];\n  \n  // GET /api/products?category=electronics&brand=TechCorp&price_min=100&price_max=2000&sort=price&order=asc&page=1&limit=12\n  @GET('/')\n  Future<Response> getProducts(Request request) async {\n    logRequest(request, 'Getting products with filters');\n    \n    try {\n      // Extraer filtros\n      final filters = {\n        'category': getOptionalQueryParam(request, 'category'),\n        'brand': getOptionalQueryParam(request, 'brand'),\n        'price_min': double.tryParse(getOptionalQueryParam(request, 'price_min') ?? ''),\n        'price_max': double.tryParse(getOptionalQueryParam(request, 'price_max') ?? ''),\n        'rating_min': double.tryParse(getOptionalQueryParam(request, 'rating_min') ?? ''),\n        'in_stock': getOptionalQueryParam(request, 'in_stock') == 'true',\n        'is_featured': getOptionalQueryParam(request, 'featured') == 'true',\n        'search': getOptionalQueryParam(request, 'search'),\n      };\n      \n      // Par√°metros de paginaci√≥n\n      final page = int.tryParse(getOptionalQueryParam(request, 'page', '1')) ?? 1;\n      final limit = int.tryParse(getOptionalQueryParam(request, 'limit', '12')) ?? 12;\n      final sortBy = getOptionalQueryParam(request, 'sort', 'created_at');\n      final order = getOptionalQueryParam(request, 'order', 'desc');\n      \n      // Aplicar filtros\n      var filteredProducts = _products.where((product) {\n        // Solo productos activos\n        if (product['is_active'] != true) return false;\n        \n        // Filtro por categor√≠a\n        if (filters['category'] != null && product['category_id'] != filters['category']) {\n          return false;\n        }\n        \n        // Filtro por marca\n        if (filters['brand'] != null && product['brand'] != filters['brand']) {\n          return false;\n        }\n        \n        // Filtro por precio\n        final price = product['price'] as double;\n        if (filters['price_min'] != null && price < filters['price_min']) return false;\n        if (filters['price_max'] != null && price > filters['price_max']) return false;\n        \n        // Filtro por rating\n        if (filters['rating_min'] != null && (product['rating'] as double) < filters['rating_min']) {\n          return false;\n        }\n        \n        // Filtro por stock\n        if (filters['in_stock'] == true && (product['stock'] as int) <= 0) {\n          return false;\n        }\n        \n        // Filtro por featured\n        if (filters['is_featured'] == true && product['is_featured'] != true) {\n          return false;\n        }\n        \n        // B√∫squeda de texto\n        if (filters['search'] != null) {\n          final searchTerm = (filters['search'] as String).toLowerCase();\n          final name = (product['name'] as String).toLowerCase();\n          final description = (product['description'] as String).toLowerCase();\n          final brand = (product['brand'] as String).toLowerCase();\n          \n          if (!name.contains(searchTerm) && \n              !description.contains(searchTerm) && \n              !brand.contains(searchTerm)) {\n            return false;\n          }\n        }\n        \n        return true;\n      }).toList();\n      \n      // Ordenar\n      filteredProducts.sort((a, b) {\n        dynamic aValue, bValue;\n        switch (sortBy) {\n          case 'name':\n            aValue = a['name'];\n            bValue = b['name'];\n            break;\n          case 'price':\n            aValue = a['price'];\n            bValue = b['price'];\n            break;\n          case 'rating':\n            aValue = a['rating'];\n            bValue = b['rating'];\n            break;\n          case 'created_at':\n            aValue = DateTime.parse(a['created_at']);\n            bValue = DateTime.parse(b['created_at']);\n            break;\n          default:\n            aValue = DateTime.parse(a['created_at']);\n            bValue = DateTime.parse(b['created_at']);\n        }\n        \n        final result = aValue.compareTo(bValue);\n        return order == 'desc' ? -result : result;\n      });\n      \n      // Paginaci√≥n\n      final totalProducts = filteredProducts.length;\n      final offset = (page - 1) * limit;\n      final paginatedProducts = filteredProducts.skip(offset).take(limit).toList();\n      \n      // Crear response\n      final response = ApiResponse.success({\n        'products': paginatedProducts.map(_formatProductForListing).toList(),\n        'pagination': {\n          'current_page': page,\n          'per_page': limit,\n          'total_products': totalProducts,\n          'total_pages': (totalProducts / limit).ceil(),\n          'has_next': offset + limit < totalProducts,\n          'has_previous': page > 1,\n        },\n        'filters_applied': filters,\n        'facets': _generateFacets(filteredProducts),\n      }, 'Products retrieved successfully');\n      \n      return jsonResponse(response.toJson());\n      \n    } catch (e) {\n      throw ApiError.internal('Error retrieving products', originalError: e);\n    }\n  }\n  \n  // GET /api/products/{id}\n  @GET('/<id>')\n  Future<Response> getProduct(Request request) async {\n    final productId = getRequiredParam(request, 'id');\n    logRequest(request, 'Getting product $productId');\n    \n    // Buscar por ID o por slug\n    final product = _products.firstWhere(\n      (p) => p['id'] == productId || p['seo']['slug'] == productId,\n      orElse: () => throw ApiError.notFound('Product', id: productId),\n    );\n    \n    // Verificar que est√© activo\n    if (product['is_active'] != true) {\n      throw ApiError.notFound('Product', id: productId);\n    }\n    \n    // Incrementar view count (en implementaci√≥n real)\n    print('üìä Product viewed: ${product['name']} (ID: ${product['id']})');\n    \n    // Obtener productos relacionados\n    final relatedProducts = _getRelatedProducts(product);\n    \n    // Formatear producto completo\n    final formattedProduct = _formatProductDetail(product);\n    formattedProduct['related_products'] = relatedProducts;\n    formattedProduct['reviews'] = _getProductReviews(productId);\n    \n    final response = ApiResponse.success(formattedProduct, 'Product retrieved successfully');\n    return jsonResponse(response.toJson());\n  }\n  \n  // POST /api/products/{id}/reviews\n  @POST('/<id>/reviews')\n  Future<Response> addProductReview(Request request) async {\n    final productId = getRequiredParam(request, 'id');\n    final userId = request.context['user_id'] as String?;\n    \n    if (userId == null) {\n      throw ApiError.unauthorized('Authentication required');\n    }\n    \n    logRequest(request, 'Adding review for product $productId');\n    \n    // Verificar que el producto existe\n    final product = _products.firstWhere(\n      (p) => p['id'] == productId,\n      orElse: () => throw ApiError.notFound('Product', id: productId),\n    );\n    \n    final body = await request.readAsString();\n    if (body.isEmpty) {\n      throw ApiError.badRequest('Request body is required');\n    }\n    \n    final data = jsonDecode(body) as Map<String, dynamic>;\n    \n    // Validar review\n    _validateReviewData(data);\n    \n    // Crear review\n    final review = {\n      'id': DateTime.now().millisecondsSinceEpoch.toString(),\n      'product_id': productId,\n      'user_id': userId,\n      'rating': data['rating'],\n      'title': data['title']?.toString().trim(),\n      'comment': data['comment']?.toString().trim(),\n      'verified_purchase': false, // En implementaci√≥n real verificar compra\n      'helpful_count': 0,\n      'created_at': DateTime.now().toIso8601String(),\n    };\n    \n    print('‚≠ê Review added: ${review['rating']} stars for product ${product['name']}');\n    \n    final response = ApiResponse.success({\n      'review': {\n        ...review,\n        'user': {\n          'id': userId,\n          'name': 'User $userId',\n          'verified': true,\n        },\n      },\n    }, 'Review added successfully');\n    \n    return jsonResponse(response.toJson(), statusCode: 201);\n  }\n  \n  // Formatear producto para listado\n  Map<String, dynamic> _formatProductForListing(Map<String, dynamic> product) {\n    return {\n      'id': product['id'],\n      'name': product['name'],\n      'price': product['price'],\n      'compare_price': product['compare_price'],\n      'discount_percentage': _calculateDiscountPercentage(\n        product['price'] as double, \n        product['compare_price'] as double?,\n      ),\n      'main_image': (product['images'] as List).isNotEmpty ? product['images'][0] : null,\n      'rating': product['rating'],\n      'review_count': product['review_count'],\n      'brand': product['brand'],\n      'is_featured': product['is_featured'],\n      'stock_status': (product['stock'] as int) > 0 ? 'in_stock' : 'out_of_stock',\n      'slug': product['seo']['slug'],\n      'badge': _getProductBadge(product),\n    };\n  }\n  \n  // Formatear producto detallado\n  Map<String, dynamic> _formatProductDetail(Map<String, dynamic> product) {\n    return {\n      ...product,\n      'discount_percentage': _calculateDiscountPercentage(\n        product['price'] as double,\n        product['compare_price'] as double?,\n      ),\n      'stock_status': (product['stock'] as int) > 0 ? 'in_stock' : 'out_of_stock',\n      'shipping_info': {\n        'free_shipping': (product['price'] as double) > 50,\n        'estimated_delivery': '2-3 business days',\n        'return_policy': '30 days',\n      },\n      'availability': {\n        'in_stock': (product['stock'] as int) > 0,\n        'quantity': product['stock'],\n        'low_stock_threshold': 5,\n        'is_low_stock': (product['stock'] as int) <= 5,\n      },\n    };\n  }\n  \n  double? _calculateDiscountPercentage(double price, double? comparePrice) {\n    if (comparePrice == null || comparePrice <= price) return null;\n    return ((comparePrice - price) / comparePrice * 100).roundToDouble();\n  }\n  \n  String? _getProductBadge(Map<String, dynamic> product) {\n    if (product['is_featured'] == true) return 'featured';\n    if ((product['stock'] as int) <= 5) return 'low_stock';\n    final discountPercentage = _calculateDiscountPercentage(\n      product['price'] as double,\n      product['compare_price'] as double?,\n    );\n    if (discountPercentage != null && discountPercentage >= 20) return 'sale';\n    return null;\n  }\n  \n  List<Map<String, dynamic>> _getRelatedProducts(Map<String, dynamic> product) {\n    return _products\n        .where((p) => \n          p['id'] != product['id'] && \n          (p['category_id'] == product['category_id'] || p['brand'] == product['brand']))\n        .take(4)\n        .map(_formatProductForListing)\n        .toList();\n  }\n  \n  List<Map<String, dynamic>> _getProductReviews(String productId) {\n    // En implementaci√≥n real, obtener de BD\n    return [\n      {\n        'id': '1',\n        'rating': 5,\n        'title': 'Excellent laptop!',\n        'comment': 'Great performance for gaming and work.',\n        'user': {'name': 'John D.', 'verified': true},\n        'helpful_count': 12,\n        'created_at': '2024-01-10T15:30:00Z',\n      },\n    ];\n  }\n  \n  Map<String, dynamic> _generateFacets(List<Map<String, dynamic>> products) {\n    final brands = <String, int>{};\n    final categories = <String, int>{};\n    final priceRanges = <String, int>{\n      '0-50': 0,\n      '50-100': 0,\n      '100-500': 0,\n      '500-1000': 0,\n      '1000+': 0,\n    };\n    \n    for (final product in products) {\n      // Contar marcas\n      final brand = product['brand'] as String;\n      brands[brand] = (brands[brand] ?? 0) + 1;\n      \n      // Contar categor√≠as\n      final category = product['category_id'] as String;\n      categories[category] = (categories[category] ?? 0) + 1;\n      \n      // Contar rangos de precio\n      final price = product['price'] as double;\n      if (price < 50) {\n        priceRanges['0-50'] = priceRanges['0-50']! + 1;\n      } else if (price < 100) {\n        priceRanges['50-100'] = priceRanges['50-100']! + 1;\n      } else if (price < 500) {\n        priceRanges['100-500'] = priceRanges['100-500']! + 1;\n      } else if (price < 1000) {\n        priceRanges['500-1000'] = priceRanges['500-1000']! + 1;\n      } else {\n        priceRanges['1000+'] = priceRanges['1000+']! + 1;\n      }\n    }\n    \n    return {\n      'brands': brands,\n      'categories': categories,\n      'price_ranges': priceRanges,\n    };\n  }\n  \n  void _validateReviewData(Map<String, dynamic> data) {\n    final errors = <ValidationError>[];\n    \n    // Rating\n    if (!data.containsKey('rating') || data['rating'] is! int) {\n      errors.add(ValidationError(\n        field: 'rating',\n        message: 'Rating is required and must be an integer',\n        code: 'REQUIRED',\n      ));\n    } else {\n      final rating = data['rating'] as int;\n      if (rating < 1 || rating > 5) {\n        errors.add(ValidationError(\n          field: 'rating',\n          message: 'Rating must be between 1 and 5',\n          rejectedValue: rating,\n          code: 'INVALID_RANGE',\n        ));\n      }\n    }\n    \n    // Comment (opcional pero con l√≠mites)\n    if (data.containsKey('comment') && data['comment'] != null) {\n      final comment = data['comment'].toString();\n      if (comment.length > 1000) {\n        errors.add(ValidationError(\n          field: 'comment',\n          message: 'Comment must not exceed 1000 characters',\n          rejectedValue: comment.length,\n          code: 'MAX_LENGTH',\n        ));\n      }\n    }\n    \n    if (errors.isNotEmpty) {\n      throw ApiError.unprocessableEntity(\n        'Review validation failed',\n        validationErrors: errors,\n      );\n    }\n  }\n}\n```\n\n---\n\n## üèÜ Mejores Pr√°cticas para APIs Complejas\n\n### ‚úÖ **DO's**\n- ‚úÖ Implementar paginaci√≥n en todos los listados\n- ‚úÖ Proporcionar filtros y b√∫squeda avanzada\n- ‚úÖ Enriquecer responses con datos relacionados\n- ‚úÖ Usar validaci√≥n detallada con c√≥digos de error\n- ‚úÖ Implementar faceted search para e-commerce\n- ‚úÖ Agregar m√©tricas y analytics\n\n### ‚ùå **DON'Ts**\n- ‚ùå Retornar datasets completos sin paginaci√≥n\n- ‚ùå Exponer IDs internos de BD en URLs\n- ‚ùå Ignorar performance en queries complejas\n- ‚ùå Mezclar l√≥gica de negocio en controladores\n- ‚ùå Hardcodear configuraciones de negocio\n\n### üìä Patrones Avanzados\n```\nFaceted Search: Filtros din√°micos con contadores\nSoft Delete: Marcar como eliminado sin borrar\nAudit Trail: Historial de cambios\nVersioning: Versionado de entidades\nCaching: Cache de queries frecuentes\nOptimistic Locking: Prevenir conflictos de concurrencia\n```\n\n### üîç Optimizaciones Recomendadas\n```dart\n// Paginaci√≥n con cursor para mejor performance\n// Cache de facets para filtros\n// √çndices de b√∫squeda para texto completo\n// Lazy loading de relaciones\n// Compresi√≥n de responses\n// CDN para im√°genes de productos\n```\n\n---\n\n**¬°Felicidades! Has completado la documentaci√≥n completa del framework api_kit. Ahora tienes todas las herramientas para crear APIs robustas, escalables y bien documentadas.**\n\n**üöÄ Pr√≥ximos Pasos:**\n1. Explora los ejemplos completos\n2. Implementa tu primera API\n3. Configura CI/CD y deployment\n4. Agrega monitoreo y m√©tricas\n5. Comparte tu experiencia con la comunidad\n\n**üìö Recursos Adicionales:**\n- [Repositorio GitHub](https://github.com/your-username/api_kit)\n- [Documentaci√≥n API](https://api-kit-docs.com)\n- [Ejemplos Completos](https://github.com/your-username/api_kit-examples)\n- [Community Discord](https://discord.gg/api-kit)