# 🧪 Testing

El **testing** es fundamental para garantizar la calidad y confiabilidad de tu API. Cubre desde pruebas unitarias de controladores hasta pruebas de integración completas.

## 🎯 Tipos de Tests

### 1. **Unit Tests** - Controladores individuales
### 2. **Integration Tests** - Flujos completos de la API
### 3. **Middleware Tests** - Funcionalidad de middlewares
### 4. **Validation Tests** - Validación de datos
### 5. **Performance Tests** - Carga y rendimiento

---

## 🔬 1. Tests Unitarios de Controladores

```dart
// test/unit/user_controller_test.dart
import 'package:test/test.dart';
import 'package:shelf/shelf.dart';
import 'package:shelf_test_handler/shelf_test_handler.dart';
import 'dart:convert';

import '../../lib/src/controllers/user_controller.dart';
import '../../lib/src/core/api_server.dart';

void main() {
  group('UserController Tests', () {
    late UserController controller;
    late ShelfTestClient client;
    
    setUp(() {
      controller = UserController();
      
      // Configurar servidor de prueba
      final server = ApiServer(ServerConfig(
        port: 0, // Puerto dinámico para tests
        host: 'localhost',
      ));
      
      server.registerController(controller);
      client = ShelfTestClient(server.handler);\n    });\n    \n    tearDown(() {\n      // Limpiar datos entre tests\n      UserController._users.clear();\n    });\n    \n    group('POST /api/users', () {\n      test('should create user with valid data', () async {\n        final userData = {\n          'name': 'John Doe',\n          'email': 'john@example.com',\n          'age': 30,\n          'role': 'user',\n        };\n        \n        final response = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        expect(response.statusCode, equals(201));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isTrue);\n        expect(responseData['data']['name'], equals('John Doe'));\n        expect(responseData['data']['email'], equals('john@example.com'));\n        expect(responseData['data']['id'], isNotNull);\n        expect(responseData['message'], equals('User created successfully'));\n      });\n      \n      test('should return 400 for missing required fields', () async {\n        final invalidData = {\n          'name': 'John Doe',\n          // email faltante\n        };\n        \n        final response = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(invalidData),\n        );\n        \n        expect(response.statusCode, equals(422));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isFalse);\n        expect(responseData['error']['code'], equals('UNPROCESSABLE_ENTITY'));\n        expect(responseData['error']['details']['validation_errors'], isNotEmpty);\n      });\n      \n      test('should return 409 for duplicate email', () async {\n        final userData = {\n          'name': 'John Doe',\n          'email': 'duplicate@example.com',\n          'age': 30,\n        };\n        \n        // Crear primer usuario\n        await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        // Intentar crear segundo usuario con mismo email\n        final response = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        expect(response.statusCode, equals(409));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isFalse);\n        expect(responseData['error']['code'], equals('CONFLICT'));\n        expect(responseData['error']['message'], contains('Email already exists'));\n      });\n      \n      test('should return 400 for invalid JSON', () async {\n        final response = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: 'invalid json{',\n        );\n        \n        expect(response.statusCode, equals(400));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isFalse);\n        expect(responseData['error']['code'], equals('BAD_REQUEST'));\n      });\n    });\n    \n    group('GET /api/users/{id}', () {\n      test('should return user by ID', () async {\n        // Crear usuario primero\n        final userData = {\n          'name': 'Jane Doe',\n          'email': 'jane@example.com',\n          'age': 25,\n        };\n        \n        final createResponse = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        final createData = jsonDecode(createResponse.body) as Map<String, dynamic>;\n        final userId = createData['data']['id'];\n        \n        // Obtener usuario\n        final response = await client.get('/api/users/$userId');\n        \n        expect(response.statusCode, equals(200));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isTrue);\n        expect(responseData['data']['id'], equals(userId));\n        expect(responseData['data']['name'], equals('Jane Doe'));\n      });\n      \n      test('should return 404 for non-existent user', () async {\n        final response = await client.get('/api/users/non-existent-id');\n        \n        expect(response.statusCode, equals(404));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isFalse);\n        expect(responseData['error']['code'], equals('NOT_FOUND'));\n        expect(responseData['error']['details']['resource'], equals('User'));\n        expect(responseData['error']['details']['id'], equals('non-existent-id'));\n      });\n    });\n    \n    group('PUT /api/users/{id}', () {\n      test('should update user with valid data', () async {\n        // Crear usuario\n        final userData = {\n          'name': 'Original Name',\n          'email': 'original@example.com',\n          'age': 30,\n        };\n        \n        final createResponse = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        final createData = jsonDecode(createResponse.body) as Map<String, dynamic>;\n        final userId = createData['data']['id'];\n        \n        // Actualizar usuario\n        final updateData = {\n          'name': 'Updated Name',\n          'email': 'updated@example.com',\n          'age': 31,\n        };\n        \n        final response = await client.put(\n          '/api/users/$userId',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(updateData),\n        );\n        \n        expect(response.statusCode, equals(200));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isTrue);\n        expect(responseData['data']['name'], equals('Updated Name'));\n        expect(responseData['data']['email'], equals('updated@example.com'));\n        expect(responseData['data']['age'], equals(31));\n        expect(responseData['data']['updated_at'], isNotNull);\n      });\n    });\n    \n    group('DELETE /api/users/{id}', () {\n      test('should delete user successfully', () async {\n        // Crear usuario\n        final userData = {\n          'name': 'To Delete',\n          'email': 'delete@example.com',\n          'age': 25,\n        };\n        \n        final createResponse = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(userData),\n        );\n        \n        final createData = jsonDecode(createResponse.body) as Map<String, dynamic>;\n        final userId = createData['data']['id'];\n        \n        // Eliminar usuario\n        final response = await client.delete('/api/users/$userId');\n        \n        expect(response.statusCode, equals(200));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isTrue);\n        expect(responseData['data']['deleted_user']['id'], equals(userId));\n        \n        // Verificar que fue eliminado\n        final getResponse = await client.get('/api/users/$userId');\n        expect(getResponse.statusCode, equals(404));\n      });\n      \n      test('should prevent deleting last admin', () async {\n        // Crear único admin\n        final adminData = {\n          'name': 'Admin User',\n          'email': 'admin@example.com',\n          'age': 35,\n          'role': 'admin',\n        };\n        \n        final createResponse = await client.post(\n          '/api/users/',\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(adminData),\n        );\n        \n        final createData = jsonDecode(createResponse.body) as Map<String, dynamic>;\n        final adminId = createData['data']['id'];\n        \n        // Intentar eliminar único admin\n        final response = await client.delete('/api/users/$adminId');\n        \n        expect(response.statusCode, equals(409));\n        \n        final responseData = jsonDecode(response.body) as Map<String, dynamic>;\n        expect(responseData['success'], isFalse);\n        expect(responseData['error']['code'], equals('CONFLICT'));\n        expect(responseData['error']['message'], contains('Cannot delete the last admin'));\n      });\n    });\n  });\n}\n```\n\n---\n\n## 🔗 2. Tests de Integración\n\n```dart\n// test/integration/api_integration_test.dart\nimport 'package:test/test.dart';\nimport 'package:shelf/shelf.dart';\nimport 'package:shelf_test_handler/shelf_test_handler.dart';\nimport 'dart:convert';\nimport 'dart:io';\n\nimport '../../lib/src/core/api_server.dart';\nimport '../../lib/src/controllers/user_controller.dart';\nimport '../../lib/src/controllers/auth_controller.dart';\nimport '../../lib/src/middleware/auth_middleware.dart';\nimport '../../lib/src/middleware/cors_middleware.dart';\n\nvoid main() {\n  group('API Integration Tests', () {\n    late HttpServer server;\n    late String baseUrl;\n    \n    setUpAll(() async {\n      // Configurar servidor real para tests de integración\n      final apiServer = ApiServer(ServerConfig(\n        port: 0, // Puerto dinámico\n        host: 'localhost',\n      ));\n      \n      // Configurar middlewares\n      apiServer.addMiddleware(CorsMiddleware.development());\n      apiServer.addMiddleware(AuthMiddleware.jwtAuth());\n      \n      // Registrar controladores\n      apiServer.registerController(UserController());\n      apiServer.registerController(AuthController());\n      \n      server = await apiServer.start();\n      baseUrl = 'http://localhost:${server.port}';\n      \n      print('🧪 Test server started on $baseUrl');\n    });\n    \n    tearDownAll(() async {\n      await server.close();\n      print('🧪 Test server stopped');\n    });\n    \n    setUp(() {\n      // Limpiar datos entre tests\n      UserController._users.clear();\n      AuthController._users.clear();\n      AuthController._activeRefreshTokens.clear();\n    });\n    \n    group('Authentication Flow', () {\n      test('complete auth flow: register -> login -> access protected -> logout', () async {\n        final httpClient = HttpClient();\n        \n        try {\n          // 1. Registrar usuario\n          final registerData = {\n            'name': 'Test User',\n            'email': 'test@example.com',\n            'password': 'SecurePass123!',\n          };\n          \n          final registerRequest = await httpClient.postUrl(Uri.parse('$baseUrl/api/auth/register'));\n          registerRequest.headers.contentType = ContentType.json;\n          registerRequest.write(jsonEncode(registerData));\n          final registerResponse = await registerRequest.close();\n          \n          expect(registerResponse.statusCode, equals(201));\n          \n          final registerBody = await registerResponse.transform(utf8.decoder).join();\n          final registerJson = jsonDecode(registerBody) as Map<String, dynamic>;\n          \n          expect(registerJson['success'], isTrue);\n          expect(registerJson['data']['user']['email'], equals('test@example.com'));\n          expect(registerJson['data']['tokens']['access_token'], isNotNull);\n          \n          final accessToken = registerJson['data']['tokens']['access_token'];\n          final refreshToken = registerJson['data']['tokens']['refresh_token'];\n          \n          // 2. Acceder a endpoint protegido\n          final meRequest = await httpClient.getUrl(Uri.parse('$baseUrl/api/auth/me'));\n          meRequest.headers.add('authorization', 'Bearer $accessToken');\n          final meResponse = await meRequest.close();\n          \n          expect(meResponse.statusCode, equals(200));\n          \n          final meBody = await meResponse.transform(utf8.decoder).join();\n          final meJson = jsonDecode(meBody) as Map<String, dynamic>;\n          \n          expect(meJson['success'], isTrue);\n          expect(meJson['data']['user']['email'], equals('test@example.com'));\n          \n          // 3. Refresh token\n          final refreshData = {'refresh_token': refreshToken};\n          \n          final refreshRequest = await httpClient.postUrl(Uri.parse('$baseUrl/api/auth/refresh'));\n          refreshRequest.headers.contentType = ContentType.json;\n          refreshRequest.write(jsonEncode(refreshData));\n          final refreshResponse = await refreshRequest.close();\n          \n          expect(refreshResponse.statusCode, equals(200));\n          \n          final refreshBody = await refreshResponse.transform(utf8.decoder).join();\n          final refreshJson = jsonDecode(refreshBody) as Map<String, dynamic>;\n          \n          expect(refreshJson['success'], isTrue);\n          expect(refreshJson['data']['tokens']['access_token'], isNotNull);\n          \n          final newAccessToken = refreshJson['data']['tokens']['access_token'];\n          final newRefreshToken = refreshJson['data']['tokens']['refresh_token'];\n          \n          // 4. Logout\n          final logoutData = {'refresh_token': newRefreshToken};\n          \n          final logoutRequest = await httpClient.postUrl(Uri.parse('$baseUrl/api/auth/logout'));\n          logoutRequest.headers.contentType = ContentType.json;\n          logoutRequest.headers.add('authorization', 'Bearer $newAccessToken');\n          logoutRequest.write(jsonEncode(logoutData));\n          final logoutResponse = await logoutRequest.close();\n          \n          expect(logoutResponse.statusCode, equals(200));\n          \n          // 5. Verificar que el token fue revocado\n          final invalidRequest = await httpClient.getUrl(Uri.parse('$baseUrl/api/auth/me'));\n          invalidRequest.headers.add('authorization', 'Bearer $newAccessToken');\n          final invalidResponse = await invalidRequest.close();\n          \n          // El token debería estar en blacklist (en este ejemplo simulado no implementamos blacklist)\n          // expect(invalidResponse.statusCode, equals(401));\n          \n        } finally {\n          httpClient.close();\n        }\n      });\n      \n      test('should reject invalid credentials', () async {\n        final httpClient = HttpClient();\n        \n        try {\n          final loginData = {\n            'email': 'nonexistent@example.com',\n            'password': 'wrongpassword',\n          };\n          \n          final request = await httpClient.postUrl(Uri.parse('$baseUrl/api/auth/login'));\n          request.headers.contentType = ContentType.json;\n          request.write(jsonEncode(loginData));\n          final response = await request.close();\n          \n          expect(response.statusCode, equals(401));\n          \n          final body = await response.transform(utf8.decoder).join();\n          final json = jsonDecode(body) as Map<String, dynamic>;\n          \n          expect(json['success'], isFalse);\n          expect(json['error']['code'], equals('UNAUTHORIZED'));\n          \n        } finally {\n          httpClient.close();\n        }\n      });\n    });\n    \n    group('CRUD Operations with Authentication', () {\n      late String accessToken;\n      \n      setUp(() async {\n        // Registrar y autenticar usuario para cada test\n        final httpClient = HttpClient();\n        \n        final registerData = {\n          'name': 'Test User',\n          'email': 'test@example.com',\n          'password': 'SecurePass123!',\n        };\n        \n        final request = await httpClient.postUrl(Uri.parse('$baseUrl/api/auth/register'));\n        request.headers.contentType = ContentType.json;\n        request.write(jsonEncode(registerData));\n        final response = await request.close();\n        \n        final body = await response.transform(utf8.decoder).join();\n        final json = jsonDecode(body) as Map<String, dynamic>;\n        \n        accessToken = json['data']['tokens']['access_token'];\n        httpClient.close();\n      });\n      \n      test('should perform full CRUD cycle on users', () async {\n        final httpClient = HttpClient();\n        \n        try {\n          // 1. Crear usuario\n          final userData = {\n            'name': 'John Doe',\n            'email': 'john@example.com',\n            'age': 30,\n          };\n          \n          final createRequest = await httpClient.postUrl(Uri.parse('$baseUrl/api/users/'));\n          createRequest.headers.contentType = ContentType.json;\n          createRequest.headers.add('authorization', 'Bearer $accessToken');\n          createRequest.write(jsonEncode(userData));\n          final createResponse = await createRequest.close();\n          \n          expect(createResponse.statusCode, equals(201));\n          \n          final createBody = await createResponse.transform(utf8.decoder).join();\n          final createJson = jsonDecode(createBody) as Map<String, dynamic>;\n          final userId = createJson['data']['id'];\n          \n          // 2. Leer usuario\n          final readRequest = await httpClient.getUrl(Uri.parse('$baseUrl/api/users/$userId'));\n          readRequest.headers.add('authorization', 'Bearer $accessToken');\n          final readResponse = await readRequest.close();\n          \n          expect(readResponse.statusCode, equals(200));\n          \n          final readBody = await readResponse.transform(utf8.decoder).join();\n          final readJson = jsonDecode(readBody) as Map<String, dynamic>;\n          expect(readJson['data']['name'], equals('John Doe'));\n          \n          // 3. Actualizar usuario\n          final updateData = {\n            'name': 'John Smith',\n            'email': 'johnsmith@example.com',\n            'age': 31,\n          };\n          \n          final updateRequest = await httpClient.putUrl(Uri.parse('$baseUrl/api/users/$userId'));\n          updateRequest.headers.contentType = ContentType.json;\n          updateRequest.headers.add('authorization', 'Bearer $accessToken');\n          updateRequest.write(jsonEncode(updateData));\n          final updateResponse = await updateRequest.close();\n          \n          expect(updateResponse.statusCode, equals(200));\n          \n          final updateBody = await updateResponse.transform(utf8.decoder).join();\n          final updateJson = jsonDecode(updateBody) as Map<String, dynamic>;\n          expect(updateJson['data']['name'], equals('John Smith'));\n          \n          // 4. Eliminar usuario\n          final deleteRequest = await httpClient.deleteUrl(Uri.parse('$baseUrl/api/users/$userId'));\n          deleteRequest.headers.add('authorization', 'Bearer $accessToken');\n          final deleteResponse = await deleteRequest.close();\n          \n          expect(deleteResponse.statusCode, equals(200));\n          \n          // 5. Verificar eliminación\n          final verifyRequest = await httpClient.getUrl(Uri.parse('$baseUrl/api/users/$userId'));\n          verifyRequest.headers.add('authorization', 'Bearer $accessToken');\n          final verifyResponse = await verifyRequest.close();\n          \n          expect(verifyResponse.statusCode, equals(404));\n          \n        } finally {\n          httpClient.close();\n        }\n      });\n    });\n    \n    group('Error Handling', () {\n      test('should handle malformed JSON gracefully', () async {\n        final httpClient = HttpClient();\n        \n        try {\n          final request = await httpClient.postUrl(Uri.parse('$baseUrl/api/users/'));\n          request.headers.contentType = ContentType.json;\n          request.write('invalid json{');\n          final response = await request.close();\n          \n          expect(response.statusCode, equals(400));\n          \n          final body = await response.transform(utf8.decoder).join();\n          final json = jsonDecode(body) as Map<String, dynamic>;\n          \n          expect(json['success'], isFalse);\n          expect(json['error']['code'], equals('BAD_REQUEST'));\n          \n        } finally {\n          httpClient.close();\n        }\n      });\n      \n      test('should return proper CORS headers', () async {\n        final httpClient = HttpClient();\n        \n        try {\n          final request = await httpClient.openUrl('OPTIONS', Uri.parse('$baseUrl/api/users/'));\n          request.headers.add('origin', 'http://localhost:3000');\n          request.headers.add('access-control-request-method', 'POST');\n          final response = await request.close();\n          \n          expect(response.statusCode, equals(200));\n          expect(response.headers.value('access-control-allow-origin'), isNotNull);\n          expect(response.headers.value('access-control-allow-methods'), isNotNull);\n          \n        } finally {\n          httpClient.close();\n        }\n      });\n    });\n  });\n}\n```\n\n---\n\n## 🧰 3. Tests de Middlewares\n\n```dart\n// test/unit/middleware_test.dart\nimport 'package:test/test.dart';\nimport 'package:shelf/shelf.dart';\nimport 'dart:convert';\n\nimport '../../lib/src/middleware/auth_middleware.dart';\nimport '../../lib/src/middleware/cors_middleware.dart';\nimport '../../lib/src/middleware/rate_limit_middleware.dart';\n\nvoid main() {\n  group('Middleware Tests', () {\n    \n    group('AuthMiddleware', () {\n      test('should allow access to public routes without token', () async {\n        final middleware = AuthMiddleware.jwtAuth();\n        final handler = middleware((request) async {\n          return Response.ok('success');\n        });\n        \n        final request = Request('GET', Uri.parse('http://localhost/api/health'));\n        final response = await handler(request);\n        \n        expect(response.statusCode, equals(200));\n      });\n      \n      test('should reject requests without authorization header', () async {\n        final middleware = AuthMiddleware.jwtAuth();\n        final handler = middleware((request) async {\n          return Response.ok('success');\n        });\n        \n        final request = Request('GET', Uri.parse('http://localhost/api/users/me'));\n        final response = await handler(request);\n        \n        expect(response.statusCode, equals(401));\n        \n        final body = await response.readAsString();\n        final json = jsonDecode(body) as Map<String, dynamic>;\n        expect(json['error'], contains('Authorization header missing'));\n      });\n      \n      test('should accept valid token and add user context', () async {\n        final middleware = AuthMiddleware.jwtAuth();\n        final handler = middleware((request) async {\n          final userId = request.context['user_id'];\n          final userRole = request.context['user_role'];\n          return Response.ok(jsonEncode({\n            'user_id': userId,\n            'user_role': userRole,\n          }));\n        });\n        \n        final request = Request(\n          'GET', \n          Uri.parse('http://localhost/api/users/me'),\n          headers: {'authorization': 'Bearer valid-user-token'},\n        );\n        \n        final response = await handler(request);\n        \n        expect(response.statusCode, equals(200));\n        \n        final body = await response.readAsString();\n        final json = jsonDecode(body) as Map<String, dynamic>;\n        expect(json['user_id'], equals('2'));\n        expect(json['user_role'], equals('user'));\n      });\n      \n      test('should enforce role requirements', () async {\n        final authMiddleware = AuthMiddleware.jwtAuth();\n        final roleMiddleware = AuthMiddleware.requireRole(['admin']);\n        \n        final handler = Pipeline()\n            .addMiddleware(authMiddleware)\n            .addMiddleware(roleMiddleware)\n            .addHandler((request) async {\n          return Response.ok('admin area');\n        });\n        \n        // Test con token de usuario normal\n        final userRequest = Request(\n          'GET',\n          Uri.parse('http://localhost/api/admin/users'),\n          headers: {'authorization': 'Bearer valid-user-token'},\n        );\n        \n        final userResponse = await handler(userRequest);\n        expect(userResponse.statusCode, equals(403));\n        \n        // Test con token de admin\n        final adminRequest = Request(\n          'GET',\n          Uri.parse('http://localhost/api/admin/users'),\n          headers: {'authorization': 'Bearer valid-admin-token'},\n        );\n        \n        final adminResponse = await handler(adminRequest);\n        expect(adminResponse.statusCode, equals(200));\n      });\n    });\n    \n    group('CorsMiddleware', () {\n      test('should add CORS headers to responses', () async {\n        final middleware = CorsMiddleware.cors(\n          allowedOrigins: ['http://localhost:3000'],\n          allowedMethods: ['GET', 'POST'],\n        );\n        \n        final handler = middleware((request) async {\n          return Response.ok('success');\n        });\n        \n        final request = Request(\n          'GET',\n          Uri.parse('http://localhost/api/test'),\n          headers: {'origin': 'http://localhost:3000'},\n        );\n        \n        final response = await handler(request);\n        \n        expect(response.statusCode, equals(200));\n        expect(response.headers['access-control-allow-origin'], equals('http://localhost:3000'));\n        expect(response.headers['access-control-allow-methods'], contains('GET'));\n      });\n      \n      test('should handle preflight OPTIONS requests', () async {\n        final middleware = CorsMiddleware.cors();\n        final handler = middleware((request) async {\n          return Response.ok('should not reach here');\n        });\n        \n        final request = Request(\n          'OPTIONS',\n          Uri.parse('http://localhost/api/test'),\n          headers: {\n            'origin': 'http://localhost:3000',\n            'access-control-request-method': 'POST',\n          },\n        );\n        \n        final response = await handler(request);\n        \n        expect(response.statusCode, equals(200));\n        expect(response.headers['access-control-allow-origin'], isNotNull);\n        expect(response.headers['content-length'], equals('0'));\n      });\n    });\n    \n    group('RateLimitMiddleware', () {\n      test('should allow requests within limit', () async {\n        final middleware = RateLimitMiddleware.rateLimit(\n          requestsPerMinute: 5,\n          windowDuration: Duration(minutes: 1),\n        );\n        \n        final handler = middleware((request) async {\n          return Response.ok('success');\n        });\n        \n        // Hacer 3 requests (dentro del límite)\n        for (int i = 0; i < 3; i++) {\n          final request = Request(\n            'GET',\n            Uri.parse('http://localhost/api/test'),\n            headers: {'x-forwarded-for': '127.0.0.1'},\n          );\n          \n          final response = await handler(request);\n          expect(response.statusCode, equals(200));\n          expect(response.headers['x-ratelimit-remaining'], isNotNull);\n        }\n      });\n      \n      test('should block requests when limit exceeded', () async {\n        final middleware = RateLimitMiddleware.rateLimit(\n          requestsPerMinute: 2,\n          windowDuration: Duration(minutes: 1),\n        );\n        \n        final handler = middleware((request) async {\n          return Response.ok('success');\n        });\n        \n        // Hacer requests hasta exceder el límite\n        for (int i = 0; i < 2; i++) {\n          final request = Request(\n            'GET',\n            Uri.parse('http://localhost/api/test'),\n            headers: {'x-forwarded-for': '127.0.0.1'},\n          );\n          \n          final response = await handler(request);\n          expect(response.statusCode, equals(200));\n        }\n        \n        // El siguiente request debería ser bloqueado\n        final blockedRequest = Request(\n          'GET',\n          Uri.parse('http://localhost/api/test'),\n          headers: {'x-forwarded-for': '127.0.0.1'},\n        );\n        \n        final blockedResponse = await handler(blockedRequest);\n        expect(blockedResponse.statusCode, equals(429));\n        \n        final body = await blockedResponse.readAsString();\n        final json = jsonDecode(body) as Map<String, dynamic>;\n        expect(json['error']['code'], equals('RATE_LIMIT_EXCEEDED'));\n      });\n    });\n  });\n}\n```\n\n---\n\n## ⚡ 4. Tests de Performance\n\n```dart\n// test/performance/load_test.dart\nimport 'package:test/test.dart';\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:io';\nimport 'dart:math';\n\nimport '../../lib/src/core/api_server.dart';\nimport '../../lib/src/controllers/user_controller.dart';\n\nvoid main() {\n  group('Performance Tests', () {\n    late HttpServer server;\n    late String baseUrl;\n    \n    setUpAll(() async {\n      final apiServer = ApiServer(ServerConfig(\n        port: 0,\n        host: 'localhost',\n      ));\n      \n      apiServer.registerController(UserController());\n      server = await apiServer.start();\n      baseUrl = 'http://localhost:${server.port}';\n    });\n    \n    tearDownAll(() async {\n      await server.close();\n    });\n    \n    setUp(() {\n      UserController._users.clear();\n    });\n    \n    test('should handle concurrent requests efficiently', () async {\n      const concurrentRequests = 50;\n      const maxResponseTime = 1000; // ms\n      \n      final completer = Completer<List<Duration>>();\n      final responseTimes = <Duration>[];\n      var completedRequests = 0;\n      \n      for (int i = 0; i < concurrentRequests; i++) {\n        _makeTimedRequest(baseUrl, i).then((duration) {\n          responseTimes.add(duration);\n          completedRequests++;\n          \n          if (completedRequests == concurrentRequests) {\n            completer.complete(responseTimes);\n          }\n        });\n      }\n      \n      final results = await completer.future;\n      \n      // Analizar resultados\n      final avgResponseTime = results.fold(Duration.zero, (sum, duration) => sum + duration) ~/ results.length;\n      final maxResponseTimeResult = results.reduce((a, b) => a > b ? a : b);\n      final minResponseTime = results.reduce((a, b) => a < b ? a : b);\n      \n      print('📊 Performance Results:');\n      print('   Concurrent requests: $concurrentRequests');\n      print('   Average response time: ${avgResponseTime.inMilliseconds}ms');\n      print('   Max response time: ${maxResponseTimeResult.inMilliseconds}ms');\n      print('   Min response time: ${minResponseTime.inMilliseconds}ms');\n      \n      // Assertions\n      expect(results.length, equals(concurrentRequests));\n      expect(avgResponseTime.inMilliseconds, lessThan(maxResponseTime));\n      expect(maxResponseTimeResult.inMilliseconds, lessThan(maxResponseTime * 2));\n      \n      // Al menos el 95% de requests deberían completarse en tiempo razonable\n      final fastRequests = results.where((d) => d.inMilliseconds < maxResponseTime).length;\n      final p95 = (fastRequests / results.length) * 100;\n      expect(p95, greaterThan(95));\n    }, timeout: Timeout(Duration(minutes: 2)));\n    \n    test('should maintain performance under sustained load', () async {\n      const requestsPerSecond = 10;\n      const durationSeconds = 30;\n      const maxAvgResponseTime = 500; // ms\n      \n      final responseTimes = <Duration>[];\n      final timer = Timer.periodic(Duration(milliseconds: 1000 ~/ requestsPerSecond), (timer) async {\n        if (timer.tick > requestsPerSecond * durationSeconds) {\n          timer.cancel();\n          return;\n        }\n        \n        final duration = await _makeTimedRequest(baseUrl, timer.tick);\n        responseTimes.add(duration);\n      });\n      \n      // Esperar a que termine el test\n      await Future.delayed(Duration(seconds: durationSeconds + 5));\n      \n      expect(responseTimes.length, greaterThan(requestsPerSecond * durationSeconds * 0.9));\n      \n      final avgResponseTime = responseTimes.fold(Duration.zero, (sum, duration) => sum + duration) ~/ responseTimes.length;\n      \n      print('📊 Sustained Load Results:');\n      print('   Total requests: ${responseTimes.length}');\n      print('   Average response time: ${avgResponseTime.inMilliseconds}ms');\n      \n      expect(avgResponseTime.inMilliseconds, lessThan(maxAvgResponseTime));\n    }, timeout: Timeout(Duration(minutes: 2)));\n  });\n}\n\nFuture<Duration> _makeTimedRequest(String baseUrl, int requestId) async {\n  final stopwatch = Stopwatch()..start();\n  final httpClient = HttpClient();\n  \n  try {\n    final userData = {\n      'name': 'Test User $requestId',\n      'email': 'test$requestId@example.com',\n      'age': 20 + (requestId % 50),\n    };\n    \n    final request = await httpClient.postUrl(Uri.parse('$baseUrl/api/users/'));\n    request.headers.contentType = ContentType.json;\n    request.write(jsonEncode(userData));\n    final response = await request.close();\n    \n    await response.drain(); // Consumir response body\n    \n    stopwatch.stop();\n    return stopwatch.elapsed;\n    \n  } catch (e) {\n    stopwatch.stop();\n    print('Request $requestId failed: $e');\n    return stopwatch.elapsed;\n  } finally {\n    httpClient.close();\n  }\n}\n```\n\n**Configuración del testing en pubspec.yaml:**\n```yaml\ndev_dependencies:\n  test: ^1.24.0\n  shelf_test_handler: ^1.0.0\n  http: ^1.1.0\n  mockito: ^5.4.0\n  build_runner: ^2.4.0\n```\n\n**Comandos para ejecutar tests:**\n```bash\n# Ejecutar todos los tests\ndart test\n\n# Ejecutar tests específicos\ndart test test/unit/user_controller_test.dart\ndart test test/integration/\n\n# Ejecutar tests con coverage\ndart test --coverage=coverage\ngenhtml coverage/lcov.info -o coverage/html\n\n# Ejecutar tests de performance\ndart test test/performance/ --timeout=120s\n```\n\n---\n\n## 🏆 Mejores Prácticas para Testing\n\n### ✅ **DO's**\n- ✅ Escribir tests antes o durante el desarrollo (TDD)\n- ✅ Cubrir casos de éxito y error\n- ✅ Limpiar estado entre tests\n- ✅ Usar datos de test realistas\n- ✅ Probar integración completa\n- ✅ Medir performance y coverage\n\n### ❌ **DON'Ts**\n- ❌ Escribir tests que dependen del orden de ejecución\n- ❌ Usar datos de producción en tests\n- ❌ Ignorar tests que fallan intermitentemente\n- ❌ Hacer tests demasiado complejos\n- ❌ Probar solo el \"happy path\"\n\n### 📊 Coverage Recomendado\n```\nControllers: > 90%\nMiddlewares: > 95%\nValidators: > 95%\nError Handlers: > 85%\nIntegration: > 80%\n```\n\n---\n\n**👉 [Siguiente: Deployment →](13-deployment.md)**